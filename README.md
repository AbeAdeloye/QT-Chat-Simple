# QT-Chat-Simple
This project was devoted to the development of a client-server application that will allow users to exchange personal messages. 
The main node is the server that manages the clients, sends them messages about new users and those that are logged out of the network. 
The client application provides an interface for exchanging messages and provides information about the availability of the server.


## Objective
It is necessary to implement a client-server application that will allow you to exchange personal messages between an unlimited number of users.
Used technologies
## Qt
Qt has a feedback technology called signals and slots, an example in the figure below
Qt widgets have a lot of specific signals, but you can also add your own signals for any widget or other class that inherits from QObject.
Slots perform the function of responding to signals. Qt widgets also have predefined slots, but in practice, programmer-defined slots are more often used, will perform the actions that he needs

![image](https://user-images.githubusercontent.com/93321737/161442527-dc89617f-6a29-4262-89e5-d34f19e5826c.png)

Signals are emitted when an object changes its internal state in some way. Signals are public functions and can be generated by anyone, but the language designers recommend that signals be generated by the object in which they were defined or its subobject. We can attach multiple signals to one slot, and vice versa.
Slots are called when a signal has been attached to it and generated. Slots are normal C++ functions and can be called by the programmer as needed. They are subject to the same access level scope as regular class methods. The only difference from class methods is that they can be attached to a signal.
##Server side

### Description of implementation details
The developed application is based on the QTcpServer class. For each user, an object of the Connection class is created, which is inherited from QTcpSocket.
A separate socket is created for each client to exchange packets. It can be in 3 states:

Waiting Greeting - The initial state of the socket. The socket waits for a hello message from the client (a message with a GRTG header, see below for more on headers).

Reading Greeting - The state of the socket when the message header has been read, but the rest of the message has not. Allows you to process information sent by the client.

Ready for use - The state of the socket when the hello message has been successfully read and it is ready for use. It remains in this state until it is closed.

For the exchange of messages between the server and the user, a message exchange protocol has been developed: MESSAGE_HEADER MESSAGE_LENGTH MESSAGE OPTIONAL_MESSAGE_LENGTH OPTIONAL_MESSAGE. Additional fields are optional and are currently only used by the MSSG and EROR headers.
 ### Description of protocol headers:
GRTG is short for greeting. Used to allow the server to send and receive service information from the user. This header is currently not used in outgoing server messages.
MSSG - short for message (trans. message). Used to allow the server to forward a message from one user to another. Example: "MSSG 5 User1 6 Hello".
PING - checking the availability of the client. The server sends such a message to check if the client can exchange messages. Example: PING 1 p. The server expects to receive a response with a PONG header.
PONG - used to respond to a ping message. Example: "PONG 1 p".
ERRO is short for error (trans. error). Used to send error messages to the client. Below I will consider it in more detail.

I have handled two situations:

<b> Disconected user </b> - as soon as a user disconnects, the server should inform the client that this user is no longer online. 
Imagine that the user with the nickname User1 disconnected, then the following message will be generated: "ERRO 6 DISCON 5 User1". 
Such a message will be sent to all users who are currently connected to the server.

<b> Repeated user </b>- After a hello message has been received, the server checks to see if the same user already exists on the network. If such a user exists on the network, then it sends a message to the client that the user already exists and disables it. Let's imagine that the username is User2 and such a user is already on the network, then the following message will be sent: "ERRO 6 REPEAT 5 User2".
For the convenience of studying the project, documentation was generated using Doxygen[3], it is located in the html folder. To start working with it, you need to run any file with the ".html" extension.

### Interface Description
An example of the server application is shown below

 ![image](https://user-images.githubusercontent.com/93321737/161443019-833dacec-72fe-4920-80a7-3108de9f07c2.png)


Start button- Used to start the server.
Stop button- Used to stop the server.
Field for displaying server logs.

Application example
After starting the server, we will receive a corresponding message in the log.

![image](https://user-images.githubusercontent.com/93321737/161443253-4ecf2bd1-b220-4f2d-8a04-bdb319773d5c.png)

After starting the server, it is ready for incoming connections. An example of connecting users to the server is shown in the figure

![image](https://user-images.githubusercontent.com/93321737/161443262-02b06a1b-931b-482c-a529-7c6c4bb371d2.png)


The server prints two messages per connection. The first message (New connection with ADDRESS: PORT) means that the client has connected, a new socket has been created, and it is set to its initial state. The second message (USER_NAME identified with ADDRES: PORT) indicates that the socket has received a hello message and is in the ReadyForUse state.
To stop the server, use button 2. All users will be disabled.

### Usage Guide
In order to use the server, simply launch the application and click the Start button. After the appropriate message is displayed in the log window, the server will start listening on port 50000.


## Description of implementation details
As in the case of server development, a socket must be used to exchange messages between the server and client parts. The Connection class described earlier was used, but was slightly modified to suit the needs of the client side.
Since the client does not receive any information with the GRTG header, in this implementation, the socket goes into the Ready for use state immediately after sending the hello message.
The message structure remains the same as in the server implementation.
The ERRO header is not used in outgoing messages, only incoming ones. When a message is received that a user is logged out, the user is excluded from the list of available chats. Upon receiving a message that this nickname is already in use on the network, the user receives an appropriate error, and the application closes.

![image](https://user-images.githubusercontent.com/93321737/161443383-ff67aa04-805d-4abc-87d5-30368e9965a0.png)

For the convenience of studying the project, documentation was generated using Doxygen[3], it is located in the html folder. To start working with it, you need to run any file with the extension: ".html".

### Interface Description
An example of the operation of the client application is shown in the figure

![image](https://user-images.githubusercontent.com/93321737/161443435-1be541b5-0243-49c4-a0ea-a84a50a7b17d.png)

A text field that is used to display the server address and port. The connection to the server is established, the text is highlighted in green. Otherwise, it lights red.
The text field that displays the username.
An input field that is used to enter a message.
The send message button can only be used if the user is selected from window 5.
A window that displays a list of users who are currently online.
A field that displays messages with the user selected in window 5.

### Application example
Let's imagine that we have 3 users named User1, User2, User3. They all successfully connected to the server, then the application window will look like in the picture

![image](https://user-images.githubusercontent.com/93321737/161443503-5bd63e5f-1abb-4a8b-92b7-d110c770b93d.png)

In order to send a message to a user, you need to select a user from the left window, enter a message in the input field and click the "Send" button, as shown in the figure

![image](https://user-images.githubusercontent.com/93321737/161443529-21267c34-6989-446c-a770-f16064f8a019.png)

If you switch between users, the messages from the right window will disappear, but if you return to the user with whom you communicated during this session of the application, the history will be saved until one of the users logs out

![image](https://user-images.githubusercontent.com/93321737/161443611-f92d303e-6358-4834-b46e-c2fed01911ef.png)

![image](https://user-images.githubusercontent.com/93321737/161443619-b5ba0c45-bdd9-4efb-aba7-d15f24603545.png)

![image](https://user-images.githubusercontent.com/93321737/161443653-1cb87175-11d7-4465-b41e-eb7dd92bbbe4.png)

### Usage Guide
For the client part, a class was implemented that allows you to read data from the configs.ini file. Thus, if desired, you can change: username, server address, server port. An example of a file is given at the link in the ReadMe.md file.



